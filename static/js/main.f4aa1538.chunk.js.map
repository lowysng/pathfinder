{"version":3,"sources":["util.js","Matrix.js","search.js","App.js","index.js"],"names":["manhattan","a","b","Math","abs","y","x","eucledian","octile","max","sqrt","min","chebyshev","getNodeStyle","nodeFlag","nodeFlags","nodeStyle","width","height","border","marginLeft","marginTop","backgroundColor","Node","state","parent","action","path_cost","this","getChildNode","pathfinder","transitionModel","stepCost","getSolution","node","concat","Pathfinder","startCoords","endCoords","canvasDimensions","matrix","goalTest","coords","getPossibleActions","possibleActions","nodeIsAtXOfCanvas","push","node_x","node_y","canvasRows","numRows","nodeAtLeftEdge","nodeAtTopEdge","nodeAtRightEdge","numCols","nodeAtBottomEdge","Error","move","newX","newY","allowDiag","objectsAreEquivalent","Matrix","toggleWall","className","map","row","rowIdx","key","style","display","colIdx","onMouseOver","bfs","solution","explored","frontier","frontier_history","length","n","shift","forEach","child","some","c","bestfs","heuristic","unshift","sort","a_star","childInExplored","childInFrontier","found","find","App","NUM_ROWS","floor","window","innerHeight","NUM_COLS","innerWidth","START_COORDS","random","END_COORDS","useState","initial_matrix","start","end","i","zeroRow","Array","fill","initializeMatrix","setMatrix","search","strategy","pop","firstCheckpoint","secondCheckpoint","setTimeout","newMatrix","currentFlag","onClick","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f4aa1538.chunk.js","sourcesContent":["export const NODE_WIDTH = 30;\r\nexport const NODE_HEIGHT = 30;\r\nconst MANHATTAN_MUL = 9;\r\nconst EUCLEDIAN_MUL = 9;\r\nconst OCTILE_MUL = 2.5;\r\nconst CHEBYSHEV_MUL = 2.7;\r\nconst STRAIGHT_MOVE_COST = 2.7;\r\nconst DIAGONAL_MOVE_COST = 3;\r\n\r\nexport const manhattan = (a, b) => MANHATTAN_MUL * Math.abs(a.y - b.y) + Math.abs(a.x - b.x);\r\nexport const eucledian = (a, b) => EUCLEDIAN_MUL * ((a.y - b.y) ** 2) + ((a.x - b.x) ** 2) ** 0.5;\r\nexport const octile = (a, b) => OCTILE_MUL * Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y)) + (Math.sqrt(2)-1)*(Math.min(Math.abs(a.x-b.x), Math.abs(a.y-b.y)));\r\nexport const chebyshev = (a, b) => CHEBYSHEV_MUL * Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y));\r\n\r\nexport const initializeMatrix = (row, width, start, end) => {\r\n    const matrix = [];\r\n    for (let i = 0; i < row; i++) {\r\n        const zeroRow = Array(width).fill(2);\r\n        matrix.push(zeroRow);\r\n    }\r\n    matrix[start.y][start.x] = 0;\r\n    matrix[end.y][end.x] = 1;\r\n    return matrix;\r\n}\r\n\r\nexport const getNodeStyle = nodeFlag => {\r\n    const nodeFlags = {\r\n        start: 0,\r\n        end: 1,\r\n        unexplored: 2,\r\n        frontier: 3,\r\n        explored: 4,\r\n        solution: 5,\r\n        wall: 6,\r\n    }\r\n    const nodeStyle = {\r\n        width: `${NODE_WIDTH}px`,\r\n        height: `${NODE_HEIGHT}px`,\r\n        border: '1px solid #d3d3d3',\r\n        marginLeft: '-1px',\r\n        marginTop: '-1px',\r\n        backgroundColor: '#FFFFFF',\r\n    }\r\n    if (nodeFlag === nodeFlags.start) {\r\n        nodeStyle.backgroundColor = '#32B739';\r\n    } else if (nodeFlag === nodeFlags.end) {\r\n        nodeStyle.backgroundColor = '#B73239';\r\n    } else if (nodeFlag === nodeFlags.frontier) {\r\n        nodeStyle.backgroundColor = '#b87fed';\r\n    } else if (nodeFlag === nodeFlags.explored) {\r\n        nodeStyle.backgroundColor = '#511884';\r\n    } else if (nodeFlag === nodeFlags.solution) {\r\n        nodeStyle.backgroundColor = '#FCD12A'\r\n    } else if (nodeFlag === nodeFlags.wall) {\r\n        nodeStyle.backgroundColor = '#000000'\r\n    }\r\n    return nodeStyle;\r\n}\r\n\r\nexport class Node {\r\n    constructor(state, parent, action, path_cost) {\r\n        this.state = state;\r\n        this.parent = parent;\r\n        this.action = action; \r\n        this.path_cost = path_cost;\r\n    }\r\n}\r\n\r\nexport const getChildNode = (pathfinder, parent, action) => {\r\n    return new Node(\r\n        pathfinder.transitionModel(parent.state, action),\r\n        parent,\r\n        action,\r\n        parent.path_cost + pathfinder.stepCost(action)\r\n    )\r\n}\r\n\r\nexport const getSolution = node => {\r\n    if (node.parent === null) return [node.state];\r\n    else return getSolution(node.parent).concat(node.state);\r\n}\r\n\r\nexport class Pathfinder {\r\n    constructor(startCoords, endCoords, canvasDimensions, matrix) {\r\n        this.startCoords = startCoords;\r\n        this.endCoords = endCoords;\r\n        this.canvasDimensions = canvasDimensions;\r\n        this.allowDiag = true;\r\n        this.matrix = matrix;\r\n    }\r\n\r\n    goalTest = coords => {\r\n        return coords.x === this.endCoords.x && coords.y === this.endCoords.y;\r\n    }\r\n\r\n    getPossibleActions = node => {\r\n        const possibleActions = [];\r\n        if (this.nodeIsAtXOfCanvas(node, 'top-left')) {\r\n            possibleActions.push('move-right', 'move-bottom-right', 'move-bottom');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'top-right')) {\r\n            possibleActions.push('move-left', 'move-bottom-left', 'move-bottom');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'bottom-left')) {\r\n            possibleActions.push('move-right', 'move-top-right', 'move-top');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'bottom-right')) {\r\n            possibleActions.push('move-left', 'move-top-left', 'move-top');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'top')) {\r\n            possibleActions.push('move-left', 'move-bottom-left', 'move-bottom', 'move-bottom-right', 'move-right');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'right')) {\r\n            possibleActions.push('move-top', 'move-top-left', 'move-left', 'move-bottom-left', 'move-bottom');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'bottom')) {\r\n            possibleActions.push('move-left', 'move-top-left', 'move-top', 'move-top-right', 'move-right');\r\n        } else if (this.nodeIsAtXOfCanvas(node, 'left')) {\r\n            possibleActions.push('move-top', 'move-top-right', 'move-right', 'move-bottom-right', 'move-bottom');\r\n        } else {\r\n            possibleActions.push('move-top-right', 'move-right',\r\n            'move-bottom-right', 'move-bottom', 'move-bottom-left',\r\n            'move-left', 'move-top-left', 'move-top');\r\n        }\r\n        return possibleActions;\r\n    }\r\n\r\n    nodeIsAtXOfCanvas = (node, x) => {\r\n        const node_x = node.x;\r\n        const node_y = node.y;\r\n        const canvasRows = this.canvasDimensions.numRows;\r\n        const canvasCols = this.canvasDimensions.numCols;\r\n    \r\n        const nodeAtLeftEdge = node_x === 0;\r\n        const nodeAtTopEdge = node_y === 0;\r\n        const nodeAtRightEdge = node_x === canvasCols - 1;\r\n        const nodeAtBottomEdge =  node_y === canvasRows - 1;\r\n    \r\n        switch (x) {\r\n            case 'top-left':\r\n                if (nodeAtLeftEdge && nodeAtTopEdge) return true;\r\n                return false;\r\n            case 'top-right':\r\n                if (nodeAtRightEdge && nodeAtTopEdge) return true;\r\n                return false;\r\n            case 'bottom-left':\r\n                if (nodeAtLeftEdge && node_y === nodeAtBottomEdge) return true;\r\n                return false;\r\n            case 'bottom-right':\r\n                if (nodeAtRightEdge && nodeAtBottomEdge) return true;\r\n                return false;\r\n            case 'top': \r\n                if (nodeAtTopEdge) return true;\r\n                return false;\r\n            case 'bottom': \r\n                if (nodeAtBottomEdge) return true;\r\n                return false;\r\n            case 'left':\r\n                if (nodeAtLeftEdge) return true;\r\n                return false;\r\n            case 'right':\r\n                if (nodeAtRightEdge) return true;\r\n                return false;\r\n            default:\r\n                throw new Error('X unrecognized');\r\n        }\r\n    }\r\n\r\n    transitionModel = (node, move) => {\r\n        let newX, newY;\r\n        const isNotAWall = () => this.matrix[newY][newX] !== 6;\r\n        switch (move) {\r\n            case 'move-top':\r\n                newX = node.x;\r\n                newY = node.y - 1;\r\n                break;\r\n            case 'move-top-right':\r\n                newX = node.x + 1;\r\n                newY = node.y - 1;\r\n                break;\r\n            case 'move-right':\r\n                newX = node.x + 1;\r\n                newY = node.y;\r\n                break;\r\n            case 'move-bottom-right':\r\n                newX = node.x + 1;\r\n                newY = node.y + 1;\r\n                break;\r\n            case 'move-bottom':\r\n                newX = node.x;\r\n                newY = node.y + 1;\r\n                break;\r\n            case 'move-bottom-left':\r\n                newX = node.x - 1;\r\n                newY = node.y + 1;\r\n                break;\r\n            case 'move-left':\r\n                newX = node.x - 1;\r\n                newY = node.y;\r\n                break;\r\n            case 'move-top-left':\r\n                newX = node.x - 1;\r\n                newY = node.y - 1;\r\n                break;\r\n        }\r\n        if (isNotAWall()) return { x: newX, y: newY };\r\n        else return null;\r\n    }\r\n\r\n    stepCost = move => {\r\n        switch (move) {\r\n            case 'move-top':\r\n                return STRAIGHT_MOVE_COST;\r\n            case 'move-top-right':\r\n                return DIAGONAL_MOVE_COST;\r\n            case 'move-right':\r\n                return STRAIGHT_MOVE_COST;\r\n            case 'move-bottom-right':\r\n                return DIAGONAL_MOVE_COST;\r\n            case 'move-bottom':\r\n                return STRAIGHT_MOVE_COST;\r\n            case 'move-bottom-left':\r\n                return DIAGONAL_MOVE_COST;\r\n            case 'move-left':\r\n                return STRAIGHT_MOVE_COST;\r\n            case 'move-top-left':\r\n                return DIAGONAL_MOVE_COST;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nexport const objectsAreEquivalent = (a, b) => {\r\n    return a.x === b.x && a.y === b.y;\r\n}","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { getNodeStyle } from './util';\r\nimport './App.css';\r\n\r\nfunction Matrix({ matrix, toggleWall }) {\r\n    return (\r\n        <div className=\"matrix\">\r\n        {matrix.map((row, rowIdx) => (\r\n            <div key={`${rowIdx}`} style={{ display: 'flex' }}>\r\n                {row.map((node, colIdx) => (\r\n                    <div \r\n                    key={`${rowIdx} ${colIdx}`}\r\n                    style={getNodeStyle(node)}\r\n                    onMouseOver={() => toggleWall(rowIdx, colIdx)}>\r\n                    </div>\r\n                ))}\r\n            </div>\r\n        ))}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Matrix;","import { Node, getChildNode, getSolution, objectsAreEquivalent, eucledian, manhattan } from './util';\r\n\r\nexport const bfs = pathfinder => {\r\n    // Breadth-First Search\r\n    let node = new Node(pathfinder.startCoords, null, null, 0);\r\n    let solution = null;\r\n    if (pathfinder.goalTest(node.state)) return { solution: getSolution(node), explored: [] };\r\n\r\n    const frontier = [node];\r\n    const frontier_history = [];\r\n    const explored = [];\r\n\r\n    while (frontier.length > 0 && !solution) {\r\n        frontier_history.push(frontier.map(n => n.state));\r\n        node = frontier.shift();\r\n        explored.push(node.state);\r\n        pathfinder.getPossibleActions(node.state).forEach(action => {\r\n            let child = getChildNode(pathfinder, node, action);\r\n            if (child.state) {\r\n                if (!explored.some(c => objectsAreEquivalent(c, child.state)) \r\n                && !frontier.some(n => objectsAreEquivalent(n.state, child.state))) {\r\n                    if (pathfinder.goalTest(child.state)) {\r\n                        solution = getSolution(child);\r\n                    }\r\n                    frontier.push(child);\r\n                };\r\n            }\r\n        })\r\n    }\r\n\r\n    return { solution: solution, explored: explored, frontier: frontier_history };\r\n}\r\n\r\nexport const dfs = pathfinder => {\r\n    // Depth-First Search\r\n    let node = new Node(pathfinder.startCoords, null, null, 0);\r\n    let solution = null;\r\n    if (pathfinder.goalTest(node.state)) return { solution: getSolution(node), explored: [] };\r\n\r\n    const frontier = [node];\r\n    const frontier_history = [];\r\n    const explored = [];\r\n\r\n    while (frontier.length > 0 && !solution) {\r\n        frontier_history.push(frontier.map(n => n.state));\r\n        node = frontier.shift();\r\n        explored.push(node.state);\r\n        pathfinder.getPossibleActions(node.state).forEach(action => {\r\n            let child = getChildNode(pathfinder, node, action);\r\n            if (!explored.some(c => objectsAreEquivalent(c, child.state)) \r\n            && !frontier.some(n => objectsAreEquivalent(n.state, child.state))) {\r\n                if (pathfinder.goalTest(child.state)) {\r\n                    solution = getSolution(child);\r\n                }\r\n                frontier.unshift(child);\r\n            };\r\n        })\r\n    }\r\n\r\n    return { solution: solution, explored: explored, frontier: frontier_history };\r\n}\r\n\r\nexport const bestfs = (pathfinder, heuristic) => {\r\n    let node = new Node(pathfinder.startCoords, null, null, 0);\r\n    let solution = null;\r\n    if (pathfinder.goalTest(node.state)) return { solution: getSolution(node), explored: [] };\r\n\r\n    const frontier = [node];\r\n    const frontier_history = [];\r\n    const explored = [];\r\n\r\n    while (frontier.length > 0 && !solution) {\r\n        frontier_history.push(frontier.map(n => n.state));\r\n        node = frontier.shift();\r\n        if (pathfinder.goalTest(node.state)) solution = getSolution(node);\r\n        explored.push(node.state);\r\n        pathfinder.getPossibleActions(node.state).forEach(action => {\r\n            let child = getChildNode(pathfinder, node, action);\r\n            if (child.state) {\r\n                if (!explored.some(c => objectsAreEquivalent(c, child.state)) \r\n                && !frontier.some(n => objectsAreEquivalent(n.state, child.state))) {\r\n                    frontier.unshift(child);\r\n                    frontier.sort((a, b) => (heuristic(pathfinder.endCoords, a.state) < heuristic(pathfinder.endCoords, b.state)) ? -1 : 1);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return { solution: solution, explored: explored, frontier: frontier_history };\r\n}\r\n\r\nexport const a_star = (pathfinder, heuristic) => {\r\n    let node = new Node(pathfinder.startCoords, null, null, 0);\r\n    let solution = null;\r\n    if (pathfinder.goalTest(node.state)) return { solution: getSolution(node), explored: [] };\r\n\r\n    const frontier = [node];\r\n    const frontier_history = [];\r\n    const explored = [];\r\n\r\n    let i = 0;\r\n\r\n    while (frontier.length > 0 && !solution) {\r\n        frontier_history.push(frontier.map(n => n.state));\r\n        node = frontier.shift();\r\n        if (pathfinder.goalTest(node.state)) solution = getSolution(node);\r\n        explored.push(node.state);\r\n        pathfinder.getPossibleActions(node.state).forEach(action => {\r\n            let child = getChildNode(pathfinder, node, action);\r\n            if (child.state) {\r\n                let childInExplored = explored.some(c => objectsAreEquivalent(c, child.state));\r\n                let childInFrontier = frontier.some(n => objectsAreEquivalent(n.state, child.state));\r\n                if (!childInExplored && !childInFrontier) {\r\n                    frontier.unshift(child);\r\n                    frontier.sort((a, b) => (heuristic(pathfinder.endCoords, a.state) + a.path_cost < heuristic(pathfinder.endCoords, b.state) + b.path_cost) ? -1 : 1);\r\n                }\r\n                else if (childInFrontier) {\r\n                    let found = frontier.find(node => objectsAreEquivalent(node.state, child.state));\r\n                    if ((found.path_cost + heuristic(pathfinder.endCoords, found.state) > child.path_cost + heuristic(pathfinder.endCoords, child.state))) {\r\n                        found = child;\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return { solution: solution, explored: explored, frontier: frontier_history };\r\n}","import React, { useState } from 'react';\r\nimport Matrix from './Matrix';\r\nimport { NODE_WIDTH, NODE_HEIGHT, initializeMatrix, Pathfinder, manhattan, eucledian, octile, chebyshev} from './util';\r\nimport { bfs, dfs, bestfs, a_star } from './search';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n\r\n    const NUM_ROWS = Math.floor(window.innerHeight/NODE_HEIGHT);\r\n    const NUM_COLS = Math.floor(window.innerWidth/NODE_WIDTH) - 2;\r\n    const START_COORDS = { x: Math.floor(Math.random() * NUM_COLS), y: Math.floor(Math.random() * NUM_ROWS) };\r\n    const END_COORDS = { x: Math.floor(Math.random() * NUM_COLS), y: Math.floor(Math.random() * NUM_ROWS) };\r\n    // const START_COORDS = { x: 19, y: 10 };\r\n    // const END_COORDS = { x: NUM_COLS - 12, y: NUM_ROWS - 5 };\r\n\r\n    const [startCoords, setStartCoords] = useState(START_COORDS);\r\n    const [endCoords, setEndCoords] = useState(END_COORDS);\r\n    let initial_matrix = initializeMatrix(NUM_ROWS, NUM_COLS, startCoords, endCoords);\r\n    const [matrix, setMatrix] = useState([...initial_matrix]);\r\n    const [pathfinder, setPathfinder] = useState(new Pathfinder(startCoords, endCoords, { numRows: NUM_ROWS, numCols: NUM_COLS }, matrix));\r\n\r\n    const search = (strategy, heuristic) => {\r\n        const { solution, explored, frontier } = strategy(pathfinder, heuristic);\r\n\r\n        // Animation\r\n        explored.shift();\r\n        frontier.shift();\r\n        if (strategy === bestfs || strategy === a_star) {\r\n            explored.pop();\r\n            frontier.pop();\r\n        };\r\n        solution.shift();\r\n        solution.pop();\r\n\r\n        const firstCheckpoint = explored.length;\r\n        const secondCheckpoint = explored.length + solution.length;\r\n\r\n        for (let i = 0; i < firstCheckpoint; i++) {\r\n            setTimeout(() => {\r\n                const newMatrix = [...matrix];\r\n                let frontierCoords = frontier[i];\r\n                frontierCoords.forEach(c => { if (c.x !== endCoords.x || c.y !== endCoords.y) newMatrix[c.y][c.x] = 3 });\r\n                newMatrix[explored[i].y][explored[i].x] = 4;\r\n                setMatrix(newMatrix)\r\n            }, 35 * i);\r\n        }\r\n\r\n        for (let i = firstCheckpoint; i < secondCheckpoint; i++) {\r\n            setTimeout(() => {\r\n                const newMatrix = [...matrix];\r\n                newMatrix[solution[i - firstCheckpoint].y][solution[i - firstCheckpoint].x] = 5;\r\n                setMatrix(newMatrix)\r\n            }, 35 * i);\r\n        }\r\n    }\r\n\r\n    const clear = () => {\r\n        setMatrix([...initial_matrix]);\r\n    };\r\n\r\n    const toggleWall = (y, x) => {\r\n        const newMatrix = [...matrix];\r\n        const currentFlag = newMatrix[y][x];\r\n        if (currentFlag !== 0 && currentFlag !== 1) {\r\n            (currentFlag === 6) ? newMatrix[y][x] = 2 : newMatrix[y][x] = 6;\r\n        }\r\n        initial_matrix = [...newMatrix];\r\n        setMatrix(newMatrix);\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <Matrix matrix={matrix} toggleWall={toggleWall}/>\r\n            <div className=\"buttonDisplay\">\r\n                <code>Refresh browser to reset canvas or regenerate start and end nodes</code>\r\n                <br/>\r\n                <code>Use mouse hovers to draw walls!</code>\r\n                <br/>\r\n                <div style={{display: 'flex'}}>\r\n                    <button onClick={() => search(bfs)}>Breadth-First Search</button>\r\n                    {/*<button onClick={() => search(dfs)}>Depth-First Search</button>*/}\r\n                    <button onClick={() => search(bestfs, eucledian)}>Best-First Search (Eucledian)</button>\r\n                    {/*<button onClick={() => search(bestfs, manhattan)}>Best-First Search (Manhattan)</button>*/}\r\n                    {/*<button onClick={() => search(bestfs, octile)}>Best-First Search (Octile)</button>*/}\r\n                    {/*<button onClick={() => search(bestfs, chebyshev)}>Best-First Search (Chebyshev)</button>*/}\r\n                </div>\r\n                <div style={{display: 'flex'}}>\r\n                    <button onClick={() => search(a_star, eucledian)}>A* Search (Eucledian)</button>\r\n                    <button onClick={() => search(a_star, manhattan)}>A* Search (Manhattan)</button>\r\n                    <button onClick={() => search(a_star, octile)}>A* Search (Octile)</button>\r\n                    <button onClick={() => search(a_star, chebyshev)}>A* Search (Chebyshev)</button>\r\n                </div>\r\n                {/*<button onClick={() => clear()}>Clear</button>*/}\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}